module Deeprails
  module Models
    type monitor_detail_response =
      {
        monitor_id: String,
        monitor_status: Deeprails::Models::MonitorDetailResponse::monitor_status,
        name: String,
        created_at: Time,
        description: String,
        evaluations: ::Array[Deeprails::MonitorDetailResponse::Evaluation],
        stats: Deeprails::MonitorDetailResponse::Stats,
        updated_at: Time,
        user_id: String
      }

    class MonitorDetailResponse < Deeprails::Internal::Type::BaseModel
      attr_accessor monitor_id: String

      attr_accessor monitor_status: Deeprails::Models::MonitorDetailResponse::monitor_status

      attr_accessor name: String

      attr_reader created_at: Time?

      def created_at=: (Time) -> Time

      attr_reader description: String?

      def description=: (String) -> String

      attr_reader evaluations: ::Array[Deeprails::MonitorDetailResponse::Evaluation]?

      def evaluations=: (
        ::Array[Deeprails::MonitorDetailResponse::Evaluation]
      ) -> ::Array[Deeprails::MonitorDetailResponse::Evaluation]

      attr_reader stats: Deeprails::MonitorDetailResponse::Stats?

      def stats=: (
        Deeprails::MonitorDetailResponse::Stats
      ) -> Deeprails::MonitorDetailResponse::Stats

      attr_reader updated_at: Time?

      def updated_at=: (Time) -> Time

      attr_reader user_id: String?

      def user_id=: (String) -> String

      def initialize: (
        monitor_id: String,
        monitor_status: Deeprails::Models::MonitorDetailResponse::monitor_status,
        name: String,
        ?created_at: Time,
        ?description: String,
        ?evaluations: ::Array[Deeprails::MonitorDetailResponse::Evaluation],
        ?stats: Deeprails::MonitorDetailResponse::Stats,
        ?updated_at: Time,
        ?user_id: String
      ) -> void

      def to_hash: -> {
        monitor_id: String,
        monitor_status: Deeprails::Models::MonitorDetailResponse::monitor_status,
        name: String,
        created_at: Time,
        description: String,
        evaluations: ::Array[Deeprails::MonitorDetailResponse::Evaluation],
        stats: Deeprails::MonitorDetailResponse::Stats,
        updated_at: Time,
        user_id: String
      }

      type monitor_status = :active | :inactive

      module MonitorStatus
        extend Deeprails::Internal::Type::Enum

        ACTIVE: :active
        INACTIVE: :inactive

        def self?.values: -> ::Array[Deeprails::Models::MonitorDetailResponse::monitor_status]
      end

      type evaluation =
        {
          eval_id: String,
          evaluation_status: Deeprails::Models::MonitorDetailResponse::Evaluation::evaluation_status,
          model_input: Deeprails::MonitorDetailResponse::Evaluation::ModelInput,
          model_output: String,
          run_mode: Deeprails::Models::MonitorDetailResponse::Evaluation::run_mode,
          created_at: Time,
          end_timestamp: Time,
          error_message: String,
          error_timestamp: Time,
          evaluation_result: ::Hash[Symbol, top],
          evaluation_total_cost: Float,
          guardrail_metrics: ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric],
          model_used: String,
          modified_at: Time,
          nametag: String,
          progress: Integer,
          start_timestamp: Time
        }

      class Evaluation < Deeprails::Internal::Type::BaseModel
        attr_accessor eval_id: String

        attr_accessor evaluation_status: Deeprails::Models::MonitorDetailResponse::Evaluation::evaluation_status

        attr_accessor model_input: Deeprails::MonitorDetailResponse::Evaluation::ModelInput

        attr_accessor model_output: String

        attr_accessor run_mode: Deeprails::Models::MonitorDetailResponse::Evaluation::run_mode

        attr_reader created_at: Time?

        def created_at=: (Time) -> Time

        attr_reader end_timestamp: Time?

        def end_timestamp=: (Time) -> Time

        attr_reader error_message: String?

        def error_message=: (String) -> String

        attr_reader error_timestamp: Time?

        def error_timestamp=: (Time) -> Time

        attr_reader evaluation_result: ::Hash[Symbol, top]?

        def evaluation_result=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

        attr_reader evaluation_total_cost: Float?

        def evaluation_total_cost=: (Float) -> Float

        attr_reader guardrail_metrics: ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric]?

        def guardrail_metrics=: (
          ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric]
        ) -> ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric]

        attr_reader model_used: String?

        def model_used=: (String) -> String

        attr_reader modified_at: Time?

        def modified_at=: (Time) -> Time

        attr_reader nametag: String?

        def nametag=: (String) -> String

        attr_reader progress: Integer?

        def progress=: (Integer) -> Integer

        attr_reader start_timestamp: Time?

        def start_timestamp=: (Time) -> Time

        def initialize: (
          eval_id: String,
          evaluation_status: Deeprails::Models::MonitorDetailResponse::Evaluation::evaluation_status,
          model_input: Deeprails::MonitorDetailResponse::Evaluation::ModelInput,
          model_output: String,
          run_mode: Deeprails::Models::MonitorDetailResponse::Evaluation::run_mode,
          ?created_at: Time,
          ?end_timestamp: Time,
          ?error_message: String,
          ?error_timestamp: Time,
          ?evaluation_result: ::Hash[Symbol, top],
          ?evaluation_total_cost: Float,
          ?guardrail_metrics: ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric],
          ?model_used: String,
          ?modified_at: Time,
          ?nametag: String,
          ?progress: Integer,
          ?start_timestamp: Time
        ) -> void

        def to_hash: -> {
          eval_id: String,
          evaluation_status: Deeprails::Models::MonitorDetailResponse::Evaluation::evaluation_status,
          model_input: Deeprails::MonitorDetailResponse::Evaluation::ModelInput,
          model_output: String,
          run_mode: Deeprails::Models::MonitorDetailResponse::Evaluation::run_mode,
          created_at: Time,
          end_timestamp: Time,
          error_message: String,
          error_timestamp: Time,
          evaluation_result: ::Hash[Symbol, top],
          evaluation_total_cost: Float,
          guardrail_metrics: ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric],
          model_used: String,
          modified_at: Time,
          nametag: String,
          progress: Integer,
          start_timestamp: Time
        }

        type evaluation_status =
          :in_progress | :completed | :canceled | :queued | :failed

        module EvaluationStatus
          extend Deeprails::Internal::Type::Enum

          IN_PROGRESS: :in_progress
          COMPLETED: :completed
          CANCELED: :canceled
          QUEUED: :queued
          FAILED: :failed

          def self?.values: -> ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::evaluation_status]
        end

        type model_input =
          { ground_truth: String, system_prompt: String, user_prompt: String }

        class ModelInput < Deeprails::Internal::Type::BaseModel
          attr_reader ground_truth: String?

          def ground_truth=: (String) -> String

          attr_reader system_prompt: String?

          def system_prompt=: (String) -> String

          attr_reader user_prompt: String?

          def user_prompt=: (String) -> String

          def initialize: (
            ?ground_truth: String,
            ?system_prompt: String,
            ?user_prompt: String
          ) -> void

          def to_hash: -> {
            ground_truth: String,
            system_prompt: String,
            user_prompt: String
          }
        end

        type run_mode = :precision_plus | :precision | :smart | :economy

        module RunMode
          extend Deeprails::Internal::Type::Enum

          PRECISION_PLUS: :precision_plus
          PRECISION: :precision
          SMART: :smart
          ECONOMY: :economy

          def self?.values: -> ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::run_mode]
        end

        type guardrail_metric =
          :correctness
          | :completeness
          | :instruction_adherence
          | :context_adherence
          | :ground_truth_adherence
          | :comprehensive_safety

        module GuardrailMetric
          extend Deeprails::Internal::Type::Enum

          CORRECTNESS: :correctness
          COMPLETENESS: :completeness
          INSTRUCTION_ADHERENCE: :instruction_adherence
          CONTEXT_ADHERENCE: :context_adherence
          GROUND_TRUTH_ADHERENCE: :ground_truth_adherence
          COMPREHENSIVE_SAFETY: :comprehensive_safety

          def self?.values: -> ::Array[Deeprails::Models::MonitorDetailResponse::Evaluation::guardrail_metric]
        end
      end

      type stats =
        {
          completed_evaluations: Integer,
          failed_evaluations: Integer,
          in_progress_evaluations: Integer,
          queued_evaluations: Integer,
          total_evaluations: Integer
        }

      class Stats < Deeprails::Internal::Type::BaseModel
        attr_reader completed_evaluations: Integer?

        def completed_evaluations=: (Integer) -> Integer

        attr_reader failed_evaluations: Integer?

        def failed_evaluations=: (Integer) -> Integer

        attr_reader in_progress_evaluations: Integer?

        def in_progress_evaluations=: (Integer) -> Integer

        attr_reader queued_evaluations: Integer?

        def queued_evaluations=: (Integer) -> Integer

        attr_reader total_evaluations: Integer?

        def total_evaluations=: (Integer) -> Integer

        def initialize: (
          ?completed_evaluations: Integer,
          ?failed_evaluations: Integer,
          ?in_progress_evaluations: Integer,
          ?queued_evaluations: Integer,
          ?total_evaluations: Integer
        ) -> void

        def to_hash: -> {
          completed_evaluations: Integer,
          failed_evaluations: Integer,
          in_progress_evaluations: Integer,
          queued_evaluations: Integer,
          total_evaluations: Integer
        }
      end
    end
  end
end
